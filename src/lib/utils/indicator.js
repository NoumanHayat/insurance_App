export const BIG = "42%";
export const SMALL = "19%"

/** This function returns the maximum and minimum lengths (as percentages) of the segments. These are used to determine the
 *  starting positions of the animated values `x1` and `x2` for each of the segments.
 * @param {Number} numberOfSegments - the number of segments in the indicator.
 * @param {Number} gapPercentage - the length (as a percentage) that the gaps between the segments occupy.
 * @returns {Object} - returns the `maxLength` and `minLength` of the segments in the indicator
  */
export const getMaxAndMinSegmentLengths = (numberOfSegments, gapPercentage) => {
    const denominator = numberOfSegments + 1;
    const totalSegmentsPercentage = 100 - (numberOfSegments - 1) * gapPercentage;
    const maxLength = Math.round((2 / denominator) * totalSegmentsPercentage);
    const minLength = Math.round((1 / denominator) * totalSegmentsPercentage);
    return { maxLength, minLength };
}

/** This function returns the initial coordinates for the animated values used by the segments in the indicator.
 * @param {Number} numberOfSegments - This is the number of segments in the indicator.
 * @param {Number} gapPercentage - This is the length of the gap (as a percentage) between each segment.
 * @returns {Number[]} - An array of integers representing the coordinates of the animated values
 */
export const getSegmentCoordinates = (numberOfSegments, gapPercentage) => {
    const { maxLength, minLength } = getMaxAndMinSegmentLengths(numberOfSegments, gapPercentage);
    const points = [0]; // 0 is always the first point. This is `x1` for the first segment
    for (let i = 0; i < 2 * numberOfSegments - 2; i++) {
        /** Since the first element of the points array is already known, the 0-index for the loop
         *  starts with the `x2` value of the first segment.
         */
        if (i % 2 == 0) {
            const multiplier = getEvenMultiplier(i)
            const coordinate = maxLength + multiplier * (gapPercentage + minLength);
            points.push(coordinate);
        } else {
            const { gapMultiplier, minMultiplier } = getOddMultipliers(i)
            const coordinate = maxLength + (gapMultiplier * gapPercentage) + (minMultiplier * minLength);
            points.push(coordinate);
        }
    }
    const finalPoint = 100;
    points.push(finalPoint);
    return points;
}

/** This function returns the `x1` and `x2` value for each segment's animated values.
 * @param {Number} index - The position of the segment in the group
 * @param {Number[]} segmentCoordinates - All of the coordinates for the segments
 * @param {Number} segmentGap - The gap between each segment.
 * @returns {Object} - An object with the `x1` and `x2` values for the segment.
 */
export const getMyCoordinates = (index, segmentCoordinates) => {
    const x1Index = 2 * index;
    const x2Index = (2 * index) + 1;

    const x1 = segmentCoordinates[x1Index];
    const x2 = segmentCoordinates[x2Index];
    return { x1, x2 }
}

/** This is the multiplier that is used to determine the position of a coordinate with an even-number index 
 *  in the array. It is used for both the `gapMultiplier` and the `minMultiplier`.
 *  @param {Number} index - Index of the item in the array
 *  @param {Number} - Multiplier
 *  */
const getEvenMultiplier = (index) => {
    return index - index / 2
}

/** This returns both the multipliers needed to determine the position of a coordinate with an odd-number
 *  index in the array.
 *  @param {Number} index - Index of the item in the array.
 *  @param {Object} - an object with the `gapMultiplier` and `minMultiplier` as keys and values.
 */
const getOddMultipliers = (index) => {
    const x = (index - 1) / 2;
    const gapMultiplier = x + 1;
    const minMultiplier = x;
    return { gapMultiplier, minMultiplier }
}

/** This function returns the amount by which the relevant coordinate must adjust by. The math is based
 *  on linear interpolation. The unknown range is [lengthDifference -> adjustment -> 0] which should map
 *  to [1*width -> offset -> 0*width], [2*width -> offset -> 1*width] & [3*width -> offset -> 2*width]
 *  depending on which of the pages is visible.
 *  @param {Number} offset - The value of the content offset value being generated by the scroll event handler
 *  @param {Number} pageWidth - The width of a single page in the carousel
 *  @param {Number} lengthDifference - The difference between the `maxLength` and `minLength` of a segment
 */
export const getAdjustment = (offset, pageWidth, lengthDifference) => {
    'worklet';
    const denominator = ((Math.ceil(offset/pageWidth) * pageWidth - offset)/ (offset - Math.floor(offset/pageWidth) * pageWidth)) + 1;
    const numerator = lengthDifference;
    const adjustment = numerator / denominator;
    return adjustment;
}

/** This function returns the start and finish colours for a segment. The start colour is the colour
 *  of the segment when its length is at a minimum and the finish colour is the colour of the segment when
 *  it is at its maximum length.
 *  @param {String[]} startColours - An array of hex codes for the start colours. If there is only one
 *  item in the array, then all of the segments in the indicator will have the same start colour.
 *  @param {String[]} finishColours - An array of hex codes for the finish colours. If there is only one 
 *  item in the array, then all of the segments in the indicator will have the same finish colour.
 *  @param {Number} index - The index of the item in the array.
 */
export const getMyColours = (startColours, finishColours, index) => {
    let startColour;
    let finishColour;
    if (startColours.length == 1) {
        startColour = startColours[0];
    } else {
        startColour = startColours[index];
    }
    if (finishColours.length == 1) {
        finishColour = finishColours[0];
    } else {
        finishColour = finishColours[index];
    }
    return { startColour, finishColour }
}